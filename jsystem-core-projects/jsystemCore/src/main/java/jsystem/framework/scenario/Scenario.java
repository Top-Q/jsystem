/*
 * Copyright 2005-2010 Ignis Software Tools Ltd. All rights reserved.
 */
package jsystem.framework.scenario;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Properties;
import java.util.Vector;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import jsystem.framework.FrameworkOptions;
import jsystem.framework.JSystemProperties;
import jsystem.framework.common.CommonResources;
import jsystem.framework.report.RunnerListenersManager;
import jsystem.framework.scenario.UpgradeAndBackwardCompatibility.AntElement;
import jsystem.framework.scenario.UpgradeAndBackwardCompatibility.Version;
import jsystem.framework.scenario.ValidationError.Originator;
import jsystem.framework.scenario.flow_control.AntFlowControl;
import jsystem.utils.FileUtils;
import jsystem.utils.PerformanceUtil;
import jsystem.utils.StringUtils;
import jsystem.utils.XmlUtils;
import junit.framework.SystemTest;
import junit.framework.TestResult;

import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

/**
 */
public class Scenario extends JTestContainer {

	private static DocumentBuilder db;
	private static Pattern SCENARIO_PATTERN = Pattern.compile("<!--This file was auto-generated by the jsystem runner",
			Pattern.CASE_INSENSITIVE);
	private Document doc;
	private File scenarioFile;
	private File scenariosDirectory;
	private Element root;
	protected boolean isDisable = false;

	private String externalId;
	private String projectName;

	// APPLIED - Property for knowing that the scenario is only editable locally
	// (only when it is open as a main root scenario)
	private boolean editLocalOnly = false;

	/**
	 * signals if the current scenario is marked as Test
	 */
	private boolean scenarioAsTest = false;

	/**
	 * Flag that signals if the user documentation of the scenario was changed
	 * in some point after the scenario was loaded. <br>
	 * This is usually the case when the user changed the user documentation
	 * from the runner.
	 */
	private boolean documentationDirty = false;

	/**
	 * Checks whether a given file is a runner scenario file.
	 * 
	 * @param scenarioName
	 *            full file path.
	 */
	public static boolean isScenario(String scenarioName) {
		if (!scenarioName.endsWith(".xml")
				|| !scenarioName.startsWith(File.separator + CommonResources.SCENARIOS_FOLDER_NAME)) {
			return false;
		}
		return isScenarioByRegExp(scenarioName);
	}

	public Scenario(File scenariosRootDirectory, String scenarioName, JTestContainer parent, String id, String uuid)
			throws Exception {
		super(scenarioName, parent, id, uuid);
		this.scenariosDirectory = scenariosRootDirectory;

		// Reset the name - since the scenariosDirectory is required
		setName(scenarioName);

		if (db == null) {
			db = XmlUtils.getDocumentBuilder();
		}
		load();
	}

	public Scenario(File listsDirectory, String scenarioName, JTestContainer parent) throws Exception {
		this(listsDirectory, scenarioName, parent, null, "");
	}

	public Scenario(File listsDirectory, String scenarioName) throws Exception {
		this(listsDirectory, scenarioName, null);
	}

	public Scenario(File scenariosDirectoryFiles, String name, String scenarioId, String projectName) throws Exception {
		this(scenariosDirectoryFiles, name);
		setExternalId(scenarioId);
		setProjectName(projectName);
	}

	public Scenario cloneTest() throws Exception {
		Scenario test = new Scenario(getScenariosDir(), getName(), null);
		test.rootTests = cloneRootTests(test);
		return test;
	}

	/**********************************************************************************************
	 * 
	 * Ant (XML) transformation methods
	 * 
	 * ********************************************************************************************/

	/**
	 * Loads scenario from ant script file
	 */
	public void load() throws Exception {
		boolean shouldXmlBeSaved = false;
		if ("true".equalsIgnoreCase(JSystemProperties.getInstance().getPreferenceOrDefault(
				FrameworkOptions.MOVE_PARAMS_FROM_XML_TO_PROP_ON_SCENARIO_LOAD))) {
			shouldXmlBeSaved = ScenarioHelpers.moveParamsFromXmlToPropFile(this);
		}

		HashSet<String> uuidSet = new HashSet<String>();
		HashSet<String> testIdSet = new HashSet<String>();

		int index = PerformanceUtil.startMeasure();
		boolean hasFixture = false;
		RunnerFixture fixture = null;
		rootTests = new Vector<JTest>();
		if (!scenarioFile.exists()) {
			return;
		}
		FileInputStream fis = new FileInputStream(scenarioFile);
		try {
			doc = db.parse(fis);
			Element root = doc.getDocumentElement();
			setRoot(root);
		} catch (Exception e) {
			log.log(Level.SEVERE, "fail to load scenario from file " + scenarioFile, e);
			throw e;
		} finally {
			fis.close();
		}

		loadVersion = UpgradeAndBackwardCompatibility.getScenarioVersion(getRootElement());

		setMeaningfulName();
		setTestComment(loadComment(getRootElement(), this));
		
		// We are calling the super method because we don't want to set the
		// documentation dirty flag to true.
		super.setDocumentation(loadUserDoc(getRootElement(), this));
		documentationDirty = false;
		setScenarioAsTest(loadScenarioAsTest(this));

		// APPLIED - set the edit local only after reading the value from the
		// properties file
		setEditLocalOnly(loadEditLocalOnly(this));
		markAsKnownIssue(loadMarkedAsKnownIssue(this));
		markAsNegativeTest(loadMarkedAsNegativeTest(this));
		hideInHTML(loadHiddenInHTML(this));
		setExternalId(loadExternalId(this));
		setProjectName(loadProjectName(this));

		if (isScenarioAsTest()) {
			setDisable(loadDisable(this));
		}
		/*
		 * Find the execute scenario target
		 */
		Element target = XmlUtils
				.getElementWithName(RunningProperties.ANT_TARGET, "execute scenario", getRootElement());
		if (target == null) {
			return;
		}

		/*
		 * With the flow control we need to implement a different load approach
		 * - each JTest type will need to handle its own load, similar to the
		 * way the XML is being created. The starting point, like before, would
		 * be the "execute scenario"
		 */

		// TODO: nicer coding is recommended
		HashMap<String, JTestContainer> targetAndParent = new HashMap<String, JTestContainer>();
		HashMap<String, Integer> targetAndPlace = new HashMap<String, Integer>();
		createTestsFromElement(target, targetAndParent, targetAndPlace);

		/*
		 * Go over all the elements in the "execute scenario" target for each
		 * antcall in the execute scenario find it's target find what the target
		 * invokes (test, fixure, scenario) and according to that create a new
		 * test/scenario/fixture
		 */
		ArrayList<Element> listOfCalls = XmlUtils.getElementsByTag(
				UpgradeAndBackwardCompatibility.getEntityForVersion(AntElement.antCall, loadVersion), target);
		for (Element scenarioElementCallElement : listOfCalls) {
			String targetName = scenarioElementCallElement.getAttribute(RunningProperties.ANT_TARGET);
			Element scenarioElementTarget = XmlUtils.getElementWithName(RunningProperties.ANT_TARGET, targetName,
					getRootElement());
			if (scenarioElementTarget == null) {
				showScenarioLoadErrorMsgAndHaltIfNeeded("Tests assest with id " + targetName
						+ " not found in scenario. Scenario name= " + getName());
			}
			boolean isTest = XmlUtils.getElementsByTag("test", scenarioElementTarget).size() > 0;
			boolean isScenario = XmlUtils.getElementsByTag(
					UpgradeAndBackwardCompatibility.getEntityForVersion(AntElement.ant, loadVersion),
					scenarioElementTarget).size() > 0;
			boolean isFixture = targetName.startsWith("f");

			if (isTest) {
				Element parentScenarioCallingTarget = null;
				if (getParent() != null && getParent() instanceof Scenario) {
					try {
						Scenario parent = (Scenario) getParent();
						Element mytarget = XmlUtils.getElementWithAttribute(RunningProperties.ANT_TARGET, "name",
								getTestId(), parent.getDocument().getDocumentElement());
						parentScenarioCallingTarget = XmlUtils.getElementWithAttribute(
								UpgradeAndBackwardCompatibility.getEntityForVersion(AntElement.ant, loadVersion),
								"antfile", "${scenarios.base}/" + getName() + ".xml", mytarget);
					} catch (Exception e) {
						// ignore
					}
				}
				RunnerTest test = (RunnerTest) RunnerTest.fromElement(parentScenarioCallingTarget,
						scenarioElementTarget, null, targetAndParent.get(targetName));

				if (test == null) {
					log.log(Level.WARNING, "Fail to load test " + targetName);
					continue;
				}
				try {
					test.load();
				} catch (Throwable e) {
					ValidationError validationError = new ValidationError();
					validationError.setOriginator(Originator.RUNNER);
					validationError.setTitle("Fail to load class: " + test.getClassName());
					validationError.setMessage(StringUtils.getStackTrace(e));
					validationError.setTest(test);
					test.addValidationError(validationError);
					
				}
				ValidationError[] errors = test.validate(test.getVisibleParamters(false));
				ValidationError.clearValidatorsWithOriginator(test.getValidationErrors(), Originator.TEST);
				if (errors != null) {
					for (ValidationError error : errors) {
						error.setOriginator(Originator.TEST);
					}
					test.getValidationErrors().addAll(Arrays.asList(errors));
				}

				Integer place = targetAndPlace.get(targetName);
				JTestContainer container = targetAndParent.get(targetName);
				container.rootTests.set(place, test);
				checkAndAddUUID(uuidSet, test.getUUID());
				checkAddAndFixId(testIdSet, test.getTestId());
			}
			if (isScenario) {
				Element antTask = XmlUtils.getElementsByTag(
						UpgradeAndBackwardCompatibility.getEntityForVersion(AntElement.ant, loadVersion),
						scenarioElementTarget).get(0);
				String file = antTask.getAttribute("antfile");
				file = file.substring("${scenarios.base}/".length());
				file = file.substring(0, file.length() - ".xml".length());
				String id = scenarioElementTarget.getAttribute("name");
				String uuid = loadUUID(antTask);
				Scenario s = null;
				try {
					s = new Scenario(scenariosDirectory, file, targetAndParent.get(targetName), id, uuid);
				} catch (Throwable e) {
					throw new Exception("Failed loading sub-scenario: " + file, e);
				}
				// TODO: what if not exist ?
				Integer place = targetAndPlace.get(targetName);
				JTestContainer container = targetAndParent.get(targetName);
				container.rootTests.set(place, s);
				checkAndAddUUID(uuidSet, uuid);
				checkAddAndFixId(testIdSet, id);

			}
			if (isFixture) {
				fixture = (RunnerFixture) RunnerFixture.fromElement(scenarioElementTarget, null, this);
				hasFixture = true;
			}
			// TODO: What if it is none of the above ?
		}

		updateAllTests();

		if (hasFixture) {
			setFixtureNode(fixture);
			update(true);
		} else {
			if (loadVersion != Version.JSystemLatest) {
				update();
			}
		}
		if (isRoot()) {
			PerformanceUtil.endMeasure(index, "Loading scenario: " + getName());
		}
		ScenariosManager.resetDirty();
		if (shouldXmlBeSaved) {
			ScenariosManager.setDirty();
		}
	}

	private void showScenarioLoadErrorMsgAndHaltIfNeeded(String msg) throws Exception {
		log.log(Level.SEVERE, msg);
		if (JSystemProperties.getInstance().getPreferenceOrDefault(FrameworkOptions.HALT_ON_SCENARIO_ERROR)
				.equals("true")) {
			log.info("Press on Enter to continue scenario load");
			System.in.read();
		}
	}

	/**
	 * 
	 */
	private void checkAndAddUUID(HashSet<String> uuidSet, String uuid) throws Exception {
		if (uuidSet.contains(uuid)) {
			showScenarioLoadErrorMsgAndHaltIfNeeded("The system has identified a problem in scenario structure. Element with uuid already exists. Scenario name="
					+ getName() + " element uuid=" + uuid);
		}
		uuidSet.add(uuid);
	}

	/**
	 * 
	 */
	private void checkAddAndFixId(HashSet<String> testIdSet, String id) throws Exception {
		if (testIdSet.contains(id)) {
			showScenarioLoadErrorMsgAndHaltIfNeeded("The system has identified a problem in scenario structure. Element with target name already exists. Scenario name="
					+ getName() + " target name=" + id);
		}
		testIdSet.add(id);
	}

	/**
	 * Look for the meaningful name of the scenario in the doc root comments. If
	 * found set it to the scenario.
	 */
	private void setMeaningfulName() {
		NodeList list = doc.getChildNodes();
		for (int i = 0; i < list.getLength(); i++) {
			if (list.item(i) instanceof Comment) {
				Comment c = (Comment) list.item(i);
				String value = c.getNodeValue();
				if (value != null) {
					int mIndex = value.indexOf(RunningProperties.MEANINGFUL_TAG);
					if (mIndex >= 0) {
						String mn = value.substring(mIndex + RunningProperties.MEANINGFUL_TAG.length());
						if (!StringUtils.isEmpty(mn)) {
							setMeaningfulName(mn, false);
						}
					}
				}
			}
		}
	}

	private static String loadComment(Element project, JTest test) throws Exception {
		Element commentProp = XmlUtils.getChildElementWithName("property", RunningProperties.COMMENT_TAG, project);
		String comment = null;
		if (commentProp != null) {
			comment = commentProp.getAttribute("value");
		}

		String commentFromPropsFile = ScenarioHelpers.getTestProperty(test.getFullUUID(),
				((Scenario) test.getRoot()).getName(), RunningProperties.COMMENT_TAG);
		if (commentFromPropsFile != null) {
			return commentFromPropsFile;
		}
		return comment;
	}

	/**
	 * 
	 * load the Unique scenario Id from the XML system property<br>
	 * if no value is found, generate a new one otherwise
	 * 
	 * @param target
	 *            the test target element
	 * @return the unique id String
	 */
	private static String loadUUID(Element target) {
		Element uuidProp = XmlUtils.getChildElementWithName("property", RunningProperties.UUID_TAG, target);
		if (uuidProp != null) {
			return uuidProp.getAttribute("value");
		}
		log.fine("Scenario did not have a UUID, Generating a new one");
		return getRandomUUID();
	}

	/**
	 * Loads the user documentation of test or scenario. It will search top most
	 * scenario that holds documentation related to the specified test or
	 * scenario.
	 * 
	 * @param project
	 *            Only for legacy support.
	 * @param test
	 *            test or scenario.
	 * @return user documentation if found, null if not.
	 */
	private static String loadUserDoc(final Element project, final JTest test) {
		// Gets the user documentation from the XML file. this is for legacy
		// support.
		Element documentationProp = XmlUtils.getChildElementWithName("property", RunningProperties.DOCUMENTATION_TAG,
				project);
		if (documentationProp != null) {
			return documentationProp.getAttribute("value");
		}

		// Searched for the user documentation that was set in the top most
		// scenario.
		String userDoc = ScenarioHelpers.getTestProperty(null, ((Scenario) test).getName(),
				RunningProperties.DOCUMENTATION_TAG);
		Scenario parentScenario = test.getParentScenario();
		while (parentScenario != null) {
			String tempUserDoc;
			if ((tempUserDoc = ScenarioHelpers.getTestProperty(test.getUUIDUpTo(parentScenario),
					parentScenario.getName(), RunningProperties.DOCUMENTATION_TAG)) != null) {
				userDoc = tempUserDoc;
			}
			parentScenario = parentScenario.getParentScenario();
		}
		return userDoc;
	}

	// APPLIED - load the value of the editLocalOnly property from the file
	private boolean loadEditLocalOnly(Scenario scenario) {
		// String value = ScenarioHelpers.getTestProperty(
		// scenario.getFullUUID(),((Scenario)scenario.getRoot()).getName(),
		// RunningProperties.EDIT_ONLY_LOCALLY);
		// if (value == null) {
		String value = ScenarioHelpers.getScenarioProperties(scenario.getName()).getProperty(
				RunningProperties.EDIT_ONLY_LOCALLY);
		// }
		return (value != null && value.toLowerCase().equals("true"));
	}

	private static boolean loadScenarioAsTest(Scenario s) throws Exception {
		String scenarioAsTest = ScenarioHelpers.getTestProperty(null, ((Scenario) s).getName(),
				RunningProperties.SCENARIO_AS_TEST_TAG);
		Scenario parentScenario = s.getParentScenario();
		
		//Searching for the top most level on which the property is set on
		while (parentScenario != null) {
			String tempScenarioAsTest;
			if ((tempScenarioAsTest = ScenarioHelpers.getTestProperty(s.getUUIDUpTo(parentScenario),
					parentScenario.getName(), RunningProperties.SCENARIO_AS_TEST_TAG)) != null) {
				scenarioAsTest = tempScenarioAsTest;
			}
			parentScenario = parentScenario.getParentScenario();
		}
		return (scenarioAsTest != null && scenarioAsTest.toLowerCase().equals("true"));
	}

	private static String loadExternalId(Scenario s) throws Exception {
		String value = ScenarioHelpers.getTestProperty(s.getFullUUID(), ((Scenario) s.getRoot()).getName(),
				RunningProperties.SCENARIO_EXTERNAL_ID);
		return value;
	}

	private static String loadProjectName(Scenario s) throws Exception {
		String value = ScenarioHelpers.getTestProperty(s.getFullUUID(), ((Scenario) s.getRoot()).getName(),
				RunningProperties.SCENARIO_PROJECT_NAME);
		return value;
	}

	private static boolean loadMarkedAsKnownIssue(Scenario s) throws Exception {
		String value = ScenarioHelpers.getTestProperty(s.getFullUUID(), ((Scenario) s.getRoot()).getName(),
				RunningProperties.MARKED_AS_KNOWN_ISSUE);
		if (value == null) {
			value = ScenarioHelpers.getScenarioProperties(s.getName()).getProperty(
					RunningProperties.MARKED_AS_KNOWN_ISSUE);
		}
		return (value != null && value.toLowerCase().equals("true"));
	}

	private static boolean loadMarkedAsNegativeTest(Scenario s) throws Exception {
		String value = ScenarioHelpers.getTestProperty(s.getFullUUID(), ((Scenario) s.getRoot()).getName(),
				RunningProperties.MARKED_AS_NEGATIVE_TEST);
		if (value == null) {
			value = ScenarioHelpers.getScenarioProperties(s.getName()).getProperty(
					RunningProperties.MARKED_AS_NEGATIVE_TEST);
		}
		return (value != null && value.toLowerCase().equals("true"));
	}

	private static boolean loadHiddenInHTML(Scenario s) throws Exception {
		return ScenarioHelpers.isHiddenInHTML(s.getFullUUID(), ((Scenario) s.getRoot()).getName());
	}

	private static boolean loadDisable(Scenario s) throws Exception {
		String value = ScenarioHelpers.getTestProperty(s.getFullUUID(), ((Scenario) s.getRoot()).getName(),
				RunningProperties.IS_DISABLED);
		return (value != null && value.toLowerCase().equals("true"));
	}

	/**
	 * updates scenario and write the selection to a file and save it to the
	 * test classes dir and to the test src dir.
	 * 
	 */
	public synchronized void update(boolean recursive) throws Exception {
		if (!JSystemProperties.getInstance().isJsystemRunner()) {
			return;
		}
		updateAllTests();
		if (recursive) {
			for (int i = 0; i < rootTests.size(); i++) {
				JTest t = (JTest) rootTests.elementAt(i);
				if (t instanceof JTestContainer) {
					((JTestContainer) t).update(recursive);
				}
			}
		}

		// init ant file and create and return the execute scenario target.
		Element targetScenario = initDocument();

		// go over all tests append a target that invokes them
		// to the ant script and add an antcall to the test in the execute
		// scenario target

		// Array is used since we cannot send integer as reference...
		Integer[] indexes = new Integer[2];
		indexes[0] = 0;
		indexes[1] = 0;

		for (JTest jtest : rootTests) {
			String targetName = null;
			if (jtest instanceof RunnerFixture) {
				targetName = "f" + indexes[0] + "_" + ((RunnerFixture) jtest).getClassName();
				indexes[0]++;
				jtest.setTestId(targetName);
			} else if ((jtest instanceof RunnerTest) || (jtest instanceof Scenario)) {
				targetName = "t" + indexes[1];
				indexes[1]++;
				jtest.setTestId(targetName);
			}

			// appending test target to xml
			jtest.addTestsXmlToRoot(doc, indexes);

			jtest.addExecutorXml(targetScenario, doc);
		}

		FileOutputStream fos = new FileOutputStream(scenarioFile);
		Source source = new DOMSource(doc);
		Result result = new StreamResult(fos);
		Transformer xformer = TransformerFactory.newInstance().newTransformer();
		xformer.setOutputProperty(OutputKeys.INDENT, "yes");
		xformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
		xformer.transform(source, result);
		fos.close();
		saveToSrcDirectory();
	}

	public void addTestsXmlToRoot(Document doc, Integer[] indexes) {
		Element target = doc.createElement(RunningProperties.ANT_TARGET);
		target.setAttribute("name", getTestId());

		Element ant = doc.createElement("jsystem-ant");
		target.appendChild(ant);
		ant.setAttribute("antfile", "${scenarios.base}/" + getName() + ".xml");

		// Add properties to scenario call. Taken with some changes from
		// Scenario's update
		addRunningProperties(target, doc);
		addUuidDocProperties(ant, doc);

		for (Object testObject : rootTests) {
			JTest test = (JTest) testObject;
			test.addAntPropertiesToTarget(ant, doc);
		}

		// Add test to root as target
		Element root = doc.getDocumentElement();
		Scenario r = (Scenario) getRoot();
		ScenarioHelpers
				.setTestProperty(getFullUUID(), r.getName(), RunningProperties.IS_DISABLED, "" + isDisable, true);
		root.appendChild(target);
	}

	/**
	 * Appends test + test settings to XML.
	 */
	public Element addExecutorXml(Element targetScenario, Document parentDoc) {
		// adding antcall to the target from the execute scenario target
		// TODO: add return attribute for all relevant properties from scenario
		Element antCall = parentDoc.createElement("antcallback");
		antCall.setAttribute(RunningProperties.ANT_TARGET, getTestId());

		targetScenario.appendChild(antCall);
		return antCall;
	}

	/**
	 * Initiates ant file, creates and returns "the execute scenario target"
	 */
	private Element initDocument() {
		doc = db.newDocument();
		setRoot(doc.createElement("project"));
		getRootElement().setAttribute("name", getName());
		doc.appendChild(doc
				.createComment("This file was auto-generated by the jsystem runner, do not change it manually"));
		if (getMeaningfulName() != null) {
			doc.appendChild(doc.createComment(RunningProperties.MEANINGFUL_TAG + getMeaningfulName()));
		}
		doc.appendChild(getRootElement());
		getRootElement().setAttribute("default", "execute scenario");

		Element propertiesFileFileName = doc.createElement("property");
		propertiesFileFileName.setAttribute("name", RunningProperties.TEST_PARAMETERS_FILE_NAME_PARAMETER);
		propertiesFileFileName.setAttribute("value", RunningProperties.TEST_PARAMETERS_EMPTY_FILE);
		getRootElement().appendChild(propertiesFileFileName);

		Element scenarioVersion = doc.createElement("property");
		scenarioVersion.setAttribute("name", UpgradeAndBackwardCompatibility.SCENARIO_VERSION_PROPERTY_NAME);
		scenarioVersion.setAttribute("value", UpgradeAndBackwardCompatibility.currentVersion());
		getRootElement().appendChild(scenarioVersion);

		Element uuidElement = doc.createElement("property");
		uuidElement.setAttribute("name", RunningProperties.UUID_TAG);
		uuidElement.setAttribute("value", "");
		getRootElement().appendChild(uuidElement);

		Element uuidParentElement = doc.createElement("property");
		uuidParentElement.setAttribute("name", RunningProperties.UUID_PARENT_TAG);
		uuidParentElement.setAttribute("value", "");
		getRootElement().appendChild(uuidParentElement);

		Element parentNameElement = doc.createElement("property");
		parentNameElement.setAttribute("name", RunningProperties.PARENT_NAME);
		parentNameElement.setAttribute("value", "");
		getRootElement().appendChild(parentNameElement);

		Element loadProps = doc.createElement("loadproperties");
		loadProps.setAttribute("srcFile", "${" + RunningProperties.TEST_PARAMETERS_FILE_NAME_PARAMETER + "}");
		getRootElement().appendChild(loadProps);

		addRunningProperties(getRootElement(), doc);

		Element taskdef = doc.createElement("taskdef");
		taskdef.setAttribute("name", "jsystem");
		taskdef.setAttribute("classname", "com.aqua.anttask.jsystem.JSystemTask");
		getRootElement().appendChild(taskdef);

		Element jsystemAntTaskdef = doc.createElement("taskdef");
		jsystemAntTaskdef.setAttribute("name", "jsystem-ant");
		jsystemAntTaskdef.setAttribute("classname", "com.aqua.anttask.jsystem.JSystemAntTask");
		getRootElement().appendChild(jsystemAntTaskdef);

		// Add reference for Ant Contrib library
		Element antContrib = doc.createElement("taskdef");
		antContrib.setAttribute("resource", "net/sf/antcontrib/antlib.xml");
		getRootElement().appendChild(antContrib);

		// Add type definition for JSystemScriptCondition
		Element jsystemCondition = doc.createElement("typedef");
		jsystemCondition.setAttribute("name", CommonResources.SCRIPT_CONDITION);
		jsystemCondition.setAttribute("classname", "com.aqua.anttask.jsystem.JSystemScriptCondition");
		getRootElement().appendChild(jsystemCondition);

		Element jsystemSwitchAntTaskdef = doc.createElement("taskdef");
		jsystemSwitchAntTaskdef.setAttribute("name", CommonResources.JSYSTEM_SWITCH);
		jsystemSwitchAntTaskdef.setAttribute("classname", "com.aqua.anttask.jsystem.JSystemSwitch");
		getRootElement().appendChild(jsystemSwitchAntTaskdef);

		Element jsystemForTaskAntTaskdef = doc.createElement("taskdef");
		jsystemForTaskAntTaskdef.setAttribute("name", CommonResources.JSYSTEM_FOR);
		jsystemForTaskAntTaskdef.setAttribute("classname", "com.aqua.anttask.jsystem.JSystemForTask");
		getRootElement().appendChild(jsystemForTaskAntTaskdef);

		Element jsystemSetAntProperties = doc.createElement("taskdef");
		jsystemSetAntProperties.setAttribute("name", CommonResources.SET_ANT_PROPERTIES);
		jsystemSetAntProperties.setAttribute("classname", "com.aqua.anttask.jsystem.JSystemSetAntProperties");
		getRootElement().appendChild(jsystemSetAntProperties);

		Element targetScenario = doc.createElement(RunningProperties.ANT_TARGET);
		targetScenario.setAttribute("name", "execute scenario");
		getRootElement().appendChild(targetScenario);

		return targetScenario;
	}

	public void addRunningProperties(Element element, Document doc) {
		Scenario r = (Scenario) getRoot();
		Properties p = new Properties();

		if (documentationDirty) {
			p.setProperty(RunningProperties.DOCUMENTATION_TAG, getDocumentation() == null ? "" : getDocumentation());
		}

		p.setProperty(RunningProperties.COMMENT_TAG, getComment() == null ? "" : getComment());

		p.setProperty(RunningProperties.SCENARIO_AS_TEST_TAG, "" + isScenarioAsTest());

		// APPLIED when user change data set the Edit Local Only
		p.setProperty(RunningProperties.EDIT_ONLY_LOCALLY, "" + isEditLocalOnly());

		p.setProperty(RunningProperties.MARKED_AS_KNOWN_ISSUE, "" + isMarkedAsKnownIssue());

		p.setProperty(RunningProperties.MARKED_AS_NEGATIVE_TEST, "" + isMarkedAsNegativeTest());

		p.setProperty(RunningProperties.HIDDEN_IN_HTML, "" + isHiddenInHTML());

		if (!StringUtils.isEmpty(getExternalId())) {
			p.setProperty(RunningProperties.SCENARIO_EXTERNAL_ID, "" + getExternalId());
		}
		if (!StringUtils.isEmpty(getProjectName())) {
			p.setProperty(RunningProperties.SCENARIO_PROJECT_NAME, "" + getProjectName());
		}

		ScenarioHelpers.setTestInnerProperty(getFullUUID(), r.getName(), p, true);
	}

	public void addUuidDocProperties(Element element, Document doc) {
		if (!StringUtils.isEmpty(uuid)) {
			Element scenarioDoc = doc.createElement("property");
			scenarioDoc.setAttribute("name", RunningProperties.UUID_TAG);
			scenarioDoc.setAttribute("value", uuid);
			element.appendChild(scenarioDoc);

			scenarioDoc = doc.createElement("property");
			scenarioDoc.setAttribute("name", RunningProperties.UUID_PARENT_TAG);
			scenarioDoc.setAttribute("value", "${" + RunningProperties.UUID_PARENT_TAG + "}.${"
					+ RunningProperties.UUID_TAG + "}");
			element.appendChild(scenarioDoc);

			scenarioDoc = doc.createElement("property");
			scenarioDoc.setAttribute("name", RunningProperties.PARENT_NAME);
			scenarioDoc.setAttribute("value", "${" + RunningProperties.PARENT_NAME + "}.${ant.project.name}");
			element.appendChild(scenarioDoc);
		}
	}

	/**
	 * Init a given test from the current scenario
	 * 
	 * @param test
	 *            The test to init
	 * @param index
	 *            the index of the current scenario test to init from
	 * @throws Exception
	 */
	public void initTestFromScenario(SystemTest test, int index) throws Exception {
		NodeList children = doc.getFirstChild().getChildNodes();
		if (children.item(index) instanceof Element) {
			if (children.getLength() <= index) {
				throw new Exception("Test: " + test.getName() + " wasn't found in scenario in index: " + index);
			}
			Element el = (Element) children.item(index);
			if (el.getTagName().equals("scenario") || // the element is not a
					// test
					// the element is not from the expected class
					(!test.getClass().getName().equals(el.getAttribute("class"))) ||
					// not the same test
					(!test.getName().equals(((Text) el.getFirstChild()).getData()))) {
				throw new Exception("Test: " + test.getName() + " wasn't found in scenario in index: " + index);
			}

			Element parentScenarioCallingTarget = null;
			if (getParent() != null && getParent() instanceof Scenario) {
				Scenario parent = (Scenario) getParent();
				Element mytarget = XmlUtils.getElementWithAttribute(RunningProperties.ANT_TARGET, "name", getTestId(),
						parent.getDocument().getDocumentElement());
				parentScenarioCallingTarget = XmlUtils.getElementWithAttribute("jsystem-ant", "antfile",
						"${scenarios.base}/" + getName() + ".xml", mytarget);
			}
			// passing the associated test for javadoc & annotations use
			RunnerTest rtest = (RunnerTest) RunnerTest.fromElement(parentScenarioCallingTarget,
					(Element) children.item(index), test, this);
			rtest.load();
			rtest.loadParametersAndValues();
		}
	}

	public boolean canWrite() {
		File[] scenarioFiles = getScenarioFiles();
		for (File f : scenarioFiles) {
			if (!f.canWrite()) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Renames scenario and saves it to a file with new name.<br>
	 * Notice that if the scenario is dirty the current state will not be saved
	 * to the old scenario name, only to the new one.
	 */
	public void save(String newName) throws Exception {
		// Checking state
		if (!JSystemProperties.getInstance().isJsystemRunner()) {
			return;
		}
		// Checking input
		if (newName.toLowerCase().endsWith(".xml")) {
			newName = newName.substring(0, newName.length() - 4);
		}
		if (newName.startsWith(".")) {
			newName = newName.substring(1);
		}

		ScenarioHelpers.copyScenarioPropertiesFileToNewScenario(getName(), newName);
		setName(newName);
		save();
		update();
	}

	/**
	 * Renames scenario and saves it to a file with new name.
	 */
	public synchronized void save() throws Exception {
		if (!JSystemProperties.getInstance().isJsystemRunner()) {
			return;
		}
		int index = PerformanceUtil.startMeasure();
		update(true);
		ScenarioHelpers.saveScenarioPropertiesToSrcAndClass(ScenarioHelpers.getScenarioProperties(getName()),
				getName(), false);

		if (isRoot()) {
			PerformanceUtil.endMeasure(index, "Saving scenario " + getName());
		}
	}

	public File[] getScenarioFiles() {
		File propertiesInClasses = new File(ScenarioHelpers.getScenarioPropertiesFile(getName()));
		File propertiesInSrc = new File(ScenarioHelpers.getScenarioSrcPropertiesFile(getName()));
		// scenarioFile
		File scenarioInSource = getSourceScenarioFile();
		return new File[] { propertiesInClasses, propertiesInSrc, scenarioFile, scenarioInSource };
	}

	/**********************************************************************************************
	 * 
	 * Scenario model update and quering methods
	 * 
	 * ********************************************************************************************/

	public File getScenariosDir() {
		return scenariosDirectory;
	}

	public File getScenarioFile() {
		return scenarioFile;
	}

	/**
	 * writes the scenario into the test projects src dir.
	 * 
	 * @throws Exception
	 */
	private void saveToSrcDirectory() throws Exception {
		File scenarioSrcFile = getSourceScenarioFile();
		if (scenarioSrcFile == null) {
			log.log(Level.SEVERE,
					"fail to write scenario to src directory, directory is not set in jsystem.properties or does not exist");
			return;
		}
		scenarioSrcFile.getParentFile().mkdirs();
		try {
			FileUtils.copyFile(scenarioFile, scenarioSrcFile);
		} catch (Exception e) {
			log.log(Level.SEVERE, "fail to write scenario to src directory", e);
		}

	}

	private File getSourceScenarioFile() {
		String tSrc = JSystemProperties.getInstance().getPreference(FrameworkOptions.RESOURCES_SOURCE_FOLDER);
		if (tSrc != null) {
			File tSrcFile = new File(tSrc);
			if (tSrcFile.exists()) {
				return new File(tSrc + File.separator + asFileName(getName()));
			}
		}
		return null;
	}

	public int countTestCases() {
		return allTests.size();
	}

	public String getClassName() {
		return "scenario";
	}

	public Document getDocument() {
		return doc;
	}

	public void setScenarioParameters(Parameter[] params, boolean applyToSubScenarios) throws Exception {
		Parameter[] before = ParameterUtils.clone(getScenarioParameters(true, applyToSubScenarios));
		Parameter[] after = ParameterUtils.clone(params);
		ParameterUtils.setDirty(params, false);
		ScenarioHelpers.saveScenarioParametersToFile(params, this, applyToSubScenarios, true);
		RunnerListenersManager.getInstance().testParametersChanged(getFullUUID(), before, after);
	}

	public String getTestName() {
		String sName = scenarioFile.getName().substring(0, scenarioFile.getName().length() - 4);
		if (getMeaningfulName() != null
				&& !"true".equals(JSystemProperties.getInstance()
						.getPreference(FrameworkOptions.IGNORE_MEANINGFUL_NAME))) {
			sName = getMeaningfulName();
		}
		if (getComment() == null || getComment().trim().equals("")) {
			setTestComment(null);
			return sName;
		}
		return sName + " - " + getComment();
	}

	/**
	 */
	private static boolean isScenarioByRegExp(String scenarioName) {
		try {
			CharSequence charSequence = FileUtils.sequentialSequenceFromFile(JSystemProperties.getCurrentTestsPath()
					+ scenarioName, 100);
			Matcher m = SCENARIO_PATTERN.matcher(charSequence);
			return m.find();
		} catch (Exception e) {
			log.log(Level.WARNING, "Failed checking whether " + scenarioName + " is a scenario file. " + e.getMessage());
			log.log(Level.FINE, "Failed checking whether " + scenarioName + " is a scenario file. ", e);
			return false;
		}
	}

	/**
	 * Scenario name convention is "<scenariosDirectory>/.../<scenarionName>"
	 * 
	 * @param scenarioName
	 *            the scenario name
	 */
	public void setName(String scenarioName) {
		// making sure scenario name is in format dir/dir2/dir3/name.xml
		super.setName(FileUtils.replaceSeparator(scenarioName));
		this.scenarioFile = new File(scenariosDirectory + File.separator + asFileName(scenarioName));
		scenarioFile.getParentFile().mkdirs();
	}

	/**
	 * Returns scanerio file name
	 * 
	 * @param scenarioName
	 *            the scenario's name
	 * @return the name as file
	 */
	private String asFileName(String scenarioName) {
		return scenarioName + ".xml";
	}

	public void setXmlFields(Properties fields) {
		throw new RuntimeException("method should not be called");
	}

	public void setTestClassParameters() {
		throw new RuntimeException("Should not be invoked");
	}

	public void run(TestResult result) {
		throw new RuntimeException("Should not be invoked");
	}

	/**
	 * Execute the meaningful name from the scenario file
	 * 
	 * @param scenarioFile
	 *            the file identify as scenario file
	 * @return the meaningful name if set of null if not.
	 */
	public static String getMeaningfulNameFromScenarioFile(File scenarioFile) {
		try {
			String fileContent = FileUtils.read(scenarioFile);
			Pattern p = Pattern.compile("\\<!--\\s*" + RunningProperties.MEANINGFUL_TAG + "\\s*(.*)\\--\\>");
			Matcher m = p.matcher(fileContent);
			if (m.find()) {
				return m.group(1);
			}
		} catch (IOException e) {
			return null;
		} catch (Throwable e) {
			log.warning("Problem reading meaningful name from Scenario: " + scenarioFile.getAbsolutePath()
					+ "! Please check the xml file.");
			return null;
		}
		return null;
	}

	/**
	 * get parameters that are requested by tests as scenario parameters
	 * 
	 * @param doFilter
	 *            get only visible parameters
	 * @return
	 */
	public ScenarioParameter[] getScenarioParameters(boolean doFilter, boolean recursive) {
		HashMap<String, Parameter> params = new HashMap<String, Parameter>();
		Properties prop = ScenarioHelpers.getScenarioParameters(this);

		Vector<JTest> tests = recursive ? allTests : rootTests;
		for (int i = 0; i < tests.size(); i++) {
			JTest jt = (JTest) tests.elementAt(i);
			Parameter[] tparams;
			if (jt instanceof Scenario) { // Will change when we add recursive
											// parameters
				continue;
			} else if (jt instanceof AntFlowControl) { // view flow control
				tparams = ((AntFlowControl) jt).getTestParameters(doFilter, recursive, true);
			} else { // RunnerTest
				jt.loadParametersAndValues();
				if (doFilter) {
					tparams = jt.getVisibleParamters(false);
				} else {
					tparams = jt.getParameters();
				}
			}

			for (int j = 0; j < tparams.length; j++) {
				if (ParametersManager.isScenarioReference(tparams[j].getValue())) {
					String[] names = ParametersManager.getReferenceKeys(tparams[j].getValue());
					for (String name : names) {
						if (params.containsKey(name)) {
							continue;
						}
						Object value = ScenarioHelpers.getScenarioParametersValue(jt.getParent(), name);
						value = (value == null) ? "" : value;
						ScenarioParameter p = createScenarioParameter(name, value);

						params.put(name, p);
					}
				}

			}
		}

		for (Object key : prop.keySet()) {
			if (!key.toString().contains(".")) {
				String name = key.toString();
				if (!params.containsKey(name)) {
					continue;
				}
				String value = prop.getProperty(name);

				ScenarioParameter p = createScenarioParameter(name, value);
				params.put(name, p);
			}
		}

		return (ScenarioParameter[]) params.values().toArray(new ScenarioParameter[0]);
	}

	private ScenarioParameter createScenarioParameter(String name, Object value) {
		ScenarioParameter p = new ScenarioParameter();
		p.resetDirty();
		p.setName(name);
		value = (value == null) ? "" : value;
		p.setDefaultValue(value);
		p.setValue(value);

		return p;
	}

	public void setDocumentation(String documentation) {
		documentationDirty = true;
		super.setDocumentation(documentation);
	}

	public String getFullTestId() {
		return getName();
	}

	public String getUUID() {
		if (StringUtils.isEmpty(uuid) && getParent() != null) {
			throw new IllegalStateException("Scenario unique id is empty");
		}
		return uuid;
	}

	public String getXmlContainerTag() {
		return null;
	}

	@Override
	public DistributedExecutionParameter[] getDistributedExecutionParameters() throws Exception {
		return DistributedExecutionHelper.getHostsParameters(this);
	}

	@Override
	public void setDistributedExecutionParameters(DistributedExecutionParameter[] parameters) throws Exception {
		DistributedExecutionParameter[] before = getDistributedExecutionParameters();
		DistributedExecutionParameter[] after = parameters;
		DistributedExecutionHelper.setHostsParameters(this, parameters);
		RunnerListenersManager.getInstance().testParametersChanged(getFullUUID(), before, after);
	}

	@Override
	public Scenario getMyScenario() {
		return this;
	}

	@Override
	public Scenario getParentScenario() {
		if (isRoot()) {
			return null;
		}
		return getParent().getMyScenario();
	}

	public Element getRootElement() {
		return root;
	}

	public void setRoot(Element root) {
		this.root = root;
	}

	public boolean isScenarioAsTest() {
		return scenarioAsTest;
	}

	public void setScenarioAsTest(boolean scenarioAsTest) {
		this.scenarioAsTest = scenarioAsTest;
	}

	public void setDisable(boolean disable) {
		if (isScenarioAsTest() && !isRoot()) {
			isDisable = disable;
		} else {
			super.setDisable(disable);
		}
	}

	public boolean isDisable() {
		if (isScenarioAsTest()) {
			return isDisable;
		}
		return false;
	}

	public boolean isMarkedAsKnownIssue() {
		return super.markedAsKnownIssue && isScenarioAsTest();
	}

	public boolean isMarkedAsNegativeTest() {
		return super.markedAsNegativeTest && isScenarioAsTest();
	}

	public String getExternalId() {
		return externalId;
	}

	public void setExternalId(String externalId) {
		this.externalId = externalId;
	}

	public String getProjectName() {
		return projectName;
	}

	public void setProjectName(String projectName) {
		this.projectName = projectName;
		ScenariosManager.setDirty();
	}

	// APPLIED - SETTER AND GETTER FOR EDIT LOCAL ONLY SCENARIO PROPERTY
	public void setEditLocalOnly(boolean editLocalOnly) {
		this.editLocalOnly = editLocalOnly;
	}

	// APPLIED - SETTER AND GETTER FOR EDIT LOCAL ONLY SCENARIO PROPERTY
	public boolean isEditLocalOnly() {
		return editLocalOnly;
	}

	/**
	 * Delete the properties of all the tests in this scenario from the property
	 * file of the current root scenario
	 */
	// Limor Bortman
	@Override
	public void resetToDefault() throws Exception {
		for (JTest test : allTests) {
			test.resetToDefault();
		}

	}

}
